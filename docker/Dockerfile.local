# syntax=docker/dockerfile:1.4

ARG GO_IMAGE=golang:1.26.0
ARG RUNTIME_IMAGE=ubuntu:24.04

############################
# Base stage - commons (кешується окремо)
############################
FROM ${GO_IMAGE} AS base

WORKDIR /src

# Go proxy settings for corporate environments
ENV GOSUMDB=off
ENV GOPROXY=direct
ENV GIT_SSL_NO_VERIFY=1
ENV GOINSECURE=*

ARG COMMONS_DIR=ecommerce-commons

# Commons копіюється один раз і кешується
COPY ${COMMONS_DIR}/go.mod ${COMMONS_DIR}/go.sum ./${COMMONS_DIR}/
COPY ${COMMONS_DIR}/pkg ./${COMMONS_DIR}/pkg

############################
# Dependencies stage
############################
FROM base AS deps

ARG SERVICE_DIR=service-dir
ARG COMMONS_DIR
# API_DEPS - space separated list of API dependency directories (e.g. "ecommerce-catalog-service-api")
ARG API_DEPS=""

# Копіюємо go.mod/go.sum для кешу модулів
COPY ${SERVICE_DIR}/go.mod ${SERVICE_DIR}/go.sum ./svc/

# Копіюємо всі API залежності (вони потрібні для go.work)
# Копіюємо ввесь контекст щоб мати доступ до API модулів
COPY . /tmp/context/

# Створюємо go.work для локальної розробки з усіма залежностями
WORKDIR /src
RUN set -e && \
    echo "=== Docker context contents ===" && \
    ls -la /tmp/context/ && \
    echo "===============================" && \
    go work init && \
    go work use ./${COMMONS_DIR} ./svc && \
    for api_dep in ${API_DEPS}; do \
        if [ -d "/tmp/context/${api_dep}" ]; then \
            echo "Adding API dependency: ${api_dep}"; \
            cp -r "/tmp/context/${api_dep}" "/src/${api_dep}"; \
            go work use "./${api_dep}"; \
        else \
            echo "ERROR: API dependency not found: ${api_dep}" && \
            echo "Make sure it's included in 'only' paths in Tiltfile" && \
            exit 1; \
        fi; \
    done && \
    rm -rf /tmp/context && \
    echo "Final go.work:" && cat go.work

############################
# Build stage
############################
FROM deps AS builder

WORKDIR /src

ARG SERVICE_DIR=service-dir

# Копіюємо код сервісу
COPY ${SERVICE_DIR}/cmd ./svc/cmd
COPY ${SERVICE_DIR}/internal ./svc/internal
COPY ${SERVICE_DIR}/configs ./svc/configs
COPY ${SERVICE_DIR}/db ./svc/db

# Встановлення Delve debugger
RUN --mount=type=cache,target=/go/pkg/mod \
    go install github.com/go-delve/delve/cmd/dlv@v1.25.2

# Збірка бінарника з debug символами
WORKDIR /src/svc
RUN --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache/go-build \
    CGO_ENABLED=1 GOOS=linux go build -gcflags="all=-N -l" -v -o /server ./cmd/main.go

############################
# Runtime stage
############################
FROM ${RUNTIME_IMAGE} AS release

WORKDIR /

# Копіюємо Delve debugger
COPY --from=builder /go/bin/dlv /dlv

# Копіюємо бінарник сервісу та конфігурації
COPY --from=builder /server /server
COPY --from=builder /src/svc/configs/ /configs/
COPY --from=builder /src/svc/db/ /db/

# Копіюємо вихідний код для debugging (щоб Delve міг мапити breakpoints)
# Важливо: шляхи повинні співпадати з тими, що використовувались при компіляції
COPY --from=builder /src/svc /src/svc
COPY --from=builder /src/ecommerce-commons /src/ecommerce-commons

# Основний порт сервісу
EXPOSE 8080

# Debug порт для Delve
EXPOSE 2345

ENTRYPOINT ["/server"]
