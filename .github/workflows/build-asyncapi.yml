name: Build AsyncAPI Messaging API

on:
  workflow_call:
    inputs:
      asyncapi_file:
        required: true
        type: string
      avro_dir:
        required: true
        type: string
      artifact:
        required: true
        type: string
      artifact_dir:
        required: true
        type: string
      package:
        required: true
        type: string

permissions:
  contents: write

jobs:
  build-messaging:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.2'
          cache: true

      - name: Install AsyncAPI CLI
        run: npm install -g @asyncapi/cli

      - name: Cache Avro Tools
        id: cache-avro
        uses: actions/cache@v4
        with:
          path: /tmp/avro-tools.jar
          key: avro-tools-1.12.0

      - name: Download Avro Tools
        if: steps.cache-avro.outputs.cache-hit != 'true'
        run: |
          echo "Downloading Avro Tools..."
          wget https://repo1.maven.org/maven2/org/apache/avro/avro-tools/1.12.0/avro-tools-1.12.0.jar -O /tmp/avro-tools.jar

      - name: Verify Avro Tools cache
        if: steps.cache-avro.outputs.cache-hit == 'true'
        run: echo "Using cached Avro Tools"

      - name: Install Go Avro generator
        run: go install github.com/hamba/avro/v2/cmd/avrogen@latest

      - name: Validate AsyncAPI spec
        run: |
          echo "✓ Validating AsyncAPI specification..."
          asyncapi validate ${{ inputs.asyncapi_file }}

      - name: Validate Avro schemas
        run: |
          echo "✓ Validating Avro schemas with Apache Avro Tools..."
          
          # Count schemas
          schema_count=$(ls -1 ${{ inputs.avro_dir }}/*.avsc 2>/dev/null | wc -l)
          echo "Found $schema_count Avro schema(s)"
          
          if [ $schema_count -eq 0 ]; then
            echo "❌ No Avro schemas found in ${{ inputs.avro_dir }}"
            exit 1
          fi
          
          # Validate all schemas together (to resolve cross-references)
          echo "Validating all schemas together..."
          
          # Build list of all schemas
          all_schemas=""
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            all_schemas="$all_schemas $schema"
          done
          
          # Validate with all schemas in one go (resolves cross-references)
          if ! java -jar /tmp/avro-tools.jar compile schema $all_schemas /tmp/avro-validation 2>&1; then
            echo "❌ Schema validation failed"
            exit 1
          fi
          
          echo "✓ All schemas are valid"
          
          # Clean up validation output
          rm -rf /tmp/avro-validation
          
          echo "✓ Avro schemas validated successfully"

      - name: Check schema references
        run: |
          echo "✓ Checking schema cross-references..."
          
          # Check if EventMetadata is referenced correctly
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schema_name=$(basename "$schema")
            
            # Skip EventMetadata itself
            if [ "$schema_name" = "event_metadata.avsc" ]; then
              continue
            fi
            
            # Check if schema references EventMetadata
            if grep -q "com.ecommerce.events.EventMetadata" "$schema"; then
              echo "✓ $schema_name correctly references EventMetadata"
              
              # Verify EventMetadata exists
              if [ ! -f "${{ inputs.avro_dir }}/event_metadata.avsc" ]; then
                echo "❌ $schema_name references EventMetadata but event_metadata.avsc not found"
                exit 1
              fi
            fi
          done

      - name: Verify schema structure (metadata + payload pattern)
        run: |
          echo "✓ Verifying event structure follows metadata+payload pattern..."
          
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schema_name=$(basename "$schema")
            
            # Skip EventMetadata and non-event schemas
            if [[ "$schema_name" == "event_metadata.avsc" ]]; then
              continue
            fi
            
            # Check if it's an Event (ends with Event)
            if [[ "$schema_name" == *"Event"* ]] || [[ "$schema_name" == *"event.avsc" ]]; then
              # Verify it has metadata and payload fields
              if ! jq -e '.fields[] | select(.name == "metadata")' "$schema" > /dev/null; then
                echo "⚠️  $schema_name missing 'metadata' field"
              fi
              
              if ! jq -e '.fields[] | select(.name == "payload")' "$schema" > /dev/null; then
                echo "⚠️  $schema_name missing 'payload' field"
              fi
            fi
          done

      - name: Create output directory
        run: mkdir -p ${{ inputs.artifact_dir }}

      - name: Generate Go code from Avro schemas
        run: |
          echo "✓ Generating Go types from Avro schemas..."
          
          # Collect all schemas
          all_schemas=""
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            all_schemas="$all_schemas $schema"
          done
          
          # Generate all schemas together (to resolve cross-references)
          echo "Generating Go code for all schemas..."
          if ! $HOME/go/bin/avrogen -pkg ${{ inputs.package }} \
            -o "${{ inputs.artifact_dir }}/generated.gen.go" \
            -tags json:snake \
            $all_schemas; then
            echo "❌ Failed to generate Go code"
            exit 1
          fi
          
          echo "✓ All Go code generated successfully"

      - name: Generate event type constants
        run: |
          cat > ${{ inputs.artifact_dir }}/event_types.gen.go << 'EOF'
          package ${{ inputs.package }}

          // Event type constants - single source of truth for event names
          // These match the schema names and should be used in EventMetadata.EventType
          const (
          EOF
          
          # Generate constants from schema names
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            # Only generate constants for Event schemas
            if [[ "$schemaName" == *"Event" ]]; then
              # Convert ProductCreatedEvent to EventTypeProductCreated
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/EventType/')
              echo "	${constName} = \"${schemaName}\"" >> ${{ inputs.artifact_dir }}/event_types.gen.go
            fi
          done
          
          echo ")" >> ${{ inputs.artifact_dir }}/event_types.gen.go

      - name: Generate serialization helpers
        run: |
          cat > ${{ inputs.artifact_dir }}/serializer.gen.go << 'EOF'
          package ${{ inputs.package }}

          import (
          	"fmt"
          	"sync"

          	"github.com/hamba/avro/v2"
          )

          var (
          	// Pre-parsed schemas (initialized once at startup)
          	compiledSchemas     = make(map[string]avro.Schema)
          	compiledSchemasOnce sync.Once
          	schemaInitError     error
          )

          // initSchemas parses all embedded schemas once
          func initSchemas() error {
          	compiledSchemasOnce.Do(func() {
          		schemas := map[string][]byte{
          EOF
          
          # Add all schemas to the map
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            varname=$(echo "$basename" | sed -E 's/(^|_)([a-z])/\U\2/g')
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            echo "			\"${schemaName}\": ${varname}Schema," >> ${{ inputs.artifact_dir }}/serializer.gen.go
          done
          
          cat >> ${{ inputs.artifact_dir }}/serializer.gen.go << 'EOF'
          		}
          
          		for name, schemaJSON := range schemas {
          			schema, err := avro.Parse(string(schemaJSON))
          			if err != nil {
          				schemaInitError = fmt.Errorf("failed to parse schema %s: %w", name, err)
          				return
          			}
          			compiledSchemas[name] = schema
          		}
          	})
          	return schemaInitError
          }

          // Marshal serializes an event using its pre-compiled schema
          func Marshal(schemaName string, v interface{}) ([]byte, error) {
          	if err := initSchemas(); err != nil {
          		return nil, err
          	}
          	
          	schema, ok := compiledSchemas[schemaName]
          	if !ok {
          		return nil, fmt.Errorf("schema %s not found", schemaName)
          	}
          	
          	return avro.Marshal(schema, v)
          }

          // Unmarshal deserializes an event using its pre-compiled schema
          func Unmarshal(schemaName string, data []byte, v interface{}) error {
          	if err := initSchemas(); err != nil {
          		return err
          	}
          	
          	schema, ok := compiledSchemas[schemaName]
          	if !ok {
          		return fmt.Errorf("schema %s not found", schemaName)
          	}
          	
          	return avro.Unmarshal(schema, data, v)
          }
          EOF
          
          # Generate typed helpers for each event
          echo "" >> ${{ inputs.artifact_dir }}/serializer.gen.go
          echo "// Typed serialization helpers" >> ${{ inputs.artifact_dir }}/serializer.gen.go
          echo "" >> ${{ inputs.artifact_dir }}/serializer.gen.go
          
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            # Skip non-event schemas (like EventMetadata)
            if [[ "$schemaName" == *"Event" ]]; then
              cat >> ${{ inputs.artifact_dir }}/serializer.gen.go << EOF
          // Marshal${schemaName} serializes ${schemaName} to Avro bytes
          func Marshal${schemaName}(event *${schemaName}) ([]byte, error) {
          	return Marshal("${schemaName}", event)
          }

          // Unmarshal${schemaName} deserializes ${schemaName} from Avro bytes
          func Unmarshal${schemaName}(data []byte) (*${schemaName}, error) {
          	var event ${schemaName}
          	if err := Unmarshal("${schemaName}", data, &event); err != nil {
          		return nil, err
          	}
          	return &event, nil
          }

          EOF
            fi
          done

      - name: Copy AsyncAPI spec
        run: |
          echo "Copying AsyncAPI spec..."
          cp ${{ inputs.asyncapi_file }} ${{ inputs.artifact_dir }}/asyncapi.yaml

      - name: Copy Avro schemas
        run: |
          echo "Copying Avro schemas..."
          mkdir -p ${{ inputs.artifact_dir }}/schemas
          cp ${{ inputs.avro_dir }}/*.avsc ${{ inputs.artifact_dir }}/schemas/

      - name: Generate schema embeddings
        run: |
          cat > ${{ inputs.artifact_dir }}/schemas.gen.go << 'EOF'
          package ${{ inputs.package }}

          import _ "embed"

          //go:embed asyncapi.yaml
          var AsyncAPISpec []byte

          EOF

          # Add embedded Avro schemas
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            varname=$(echo "$basename" | sed -E 's/(^|_)([a-z])/\U\2/g')
            echo "//go:embed schemas/${basename}.avsc" >> ${{ inputs.artifact_dir }}/schemas.gen.go
            echo "var ${varname}Schema []byte" >> ${{ inputs.artifact_dir }}/schemas.gen.go
            echo "" >> ${{ inputs.artifact_dir }}/schemas.gen.go
          done

      - name: Validate generated Go code
        run: |
          echo "✓ Validating generated Go code..."
          
          cd ${{ inputs.artifact_dir }}
          
          # Create a temporary go.mod if needed
          if [ ! -f "go.mod" ]; then
            go mod init github.com/${{ github.repository }}/${{ inputs.artifact_dir }}
            go mod tidy
          fi
          
          # Check if code compiles
          if ! go build -o /dev/null *.go 2>&1; then
            echo "❌ Generated Go code does not compile"
            exit 1
          fi
          
          # Remove go.mod and go.sum (not needed in artifact)
          rm -f go.mod go.sum
          
          echo "✓ Generated Go code is valid and compiles"

      - name: Generate README
        run: |
          cat > ${{ inputs.artifact_dir }}/README.gen.md << 'EOF'
          # Generated Messaging API

          This package is auto-generated from AsyncAPI and Avro schemas.

          ## Usage

          ### Typed API (Recommended)

          ```go
          import "github.com/${{ github.repository }}/${{ inputs.artifact_dir }}"

          // Serialize event (no registration needed!)
          // Use event type constants for type safety
          event := &${{ inputs.package }}.YourEventName{
              Metadata: &${{ inputs.package }}.EventMetadata{
                  EventId:       "unique-id",
                  EventType:     ${{ inputs.package }}.EventTypeYourEvent, // ← Type-safe constant
                  Source:        "your-service",
                  Timestamp:     time.Now().UnixMilli(),
                  SchemaVersion: 1,
              },
              Payload: &${{ inputs.package }}.YourEventPayload{
                  // ... your payload fields
              },
          }

          // Simply call the typed marshal function
          data, err := ${{ inputs.package }}.MarshalYourEventName(event)
          if err != nil {
              log.Fatal(err)
          }

          // Deserialize with typed function
          receivedEvent, err := ${{ inputs.package }}.UnmarshalYourEventName(data)
          if err != nil {
              log.Fatal(err)
          }
          ```

          ### Generic API (for dynamic use cases)

          ```go
          // Marshal any event by schema name
          data, err := ${{ inputs.package }}.Marshal("YourEventName", event)
          if err != nil {
              log.Fatal(err)
          }

          // Unmarshal any event by schema name
          var event ${{ inputs.package }}.YourEventName
          err = ${{ inputs.package }}.Unmarshal("YourEventName", data, &event)
          if err != nil {
              log.Fatal(err)
          }
          ```

          ## Features

          ✅ **No manual schema registration** - schemas are pre-compiled at package init  
          ✅ **Type-safe helpers** - dedicated functions for each event type  
          ✅ **Type-safe event constants** - use `EventType*` constants instead of strings  
          ✅ **Zero runtime overhead** - schemas parsed once using sync.Once  
          ✅ **Embedded resources** - all schemas included in the package  

          ## Event Type Constants

          Always use the generated constants for `EventMetadata.EventType` to ensure consistency:

          EOF
          
          # List event type constants
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            if [[ "$schemaName" == *"Event" ]]; then
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/EventType/')
              echo "- \`${{ inputs.package }}.${constName}\` = \"${schemaName}\"" >> ${{ inputs.artifact_dir }}/README.gen.md
            fi
          done
          
          cat >> ${{ inputs.artifact_dir }}/README.gen.md << 'EOF'

          ## Embedded Resources

          - AsyncAPI specification: `${{ inputs.package }}.AsyncAPISpec`
          - Avro schemas: `${{ inputs.package }}.*Schema` variables

          ## Available Event Types

          EOF
          
          # List all available event types with their typed functions
          echo "The following event types have typed serialization helpers:" >> ${{ inputs.artifact_dir }}/README.gen.md
          echo "" >> ${{ inputs.artifact_dir }}/README.gen.md
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            if [[ "$schemaName" == *"Event" ]]; then
              echo "- **${schemaName}**" >> ${{ inputs.artifact_dir }}/README.gen.md
              echo "  - \`Marshal${schemaName}(event *${schemaName}) ([]byte, error)\`" >> ${{ inputs.artifact_dir }}/README.gen.md
              echo "  - \`Unmarshal${schemaName}(data []byte) (*${schemaName}, error)\`" >> ${{ inputs.artifact_dir }}/README.gen.md
              echo "" >> ${{ inputs.artifact_dir }}/README.gen.md
            fi
          done
          
          echo "## Available Schemas" >> ${{ inputs.artifact_dir }}/README.gen.md
          echo "" >> ${{ inputs.artifact_dir }}/README.gen.md
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            varname=$(echo "$basename" | sed -E 's/(^|_)([a-z])/\U\2/g')
            schema_type=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            echo "- \`${{ inputs.package }}.${varname}Schema\` - $schema_type (embedded Avro schema)" >> ${{ inputs.artifact_dir }}/README.gen.md
          done

      - name: Upload built messaging API
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact }}
          path: ${{ inputs.artifact_dir }}
