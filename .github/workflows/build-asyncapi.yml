name: Build AsyncAPI Messaging API

on:
  workflow_call:
    inputs:
      asyncapi_file:
        required: true
        type: string
      avro_dir:
        required: true
        type: string
      artifact:
        required: true
        type: string
      artifact_dir:
        required: true
        type: string
      package:
        required: true
        type: string

permissions:
  contents: write

jobs:
  build-messaging:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.2'
          cache: true

      - name: Install AsyncAPI CLI
        run: npm install -g @asyncapi/cli

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Cache Avro Tools
        id: cache-avro
        uses: actions/cache@v4
        with:
          path: /tmp/avro-tools.jar
          key: avro-tools-1.12.0

      - name: Download Avro Tools
        if: steps.cache-avro.outputs.cache-hit != 'true'
        run: |
          echo "Downloading Avro Tools..."
          wget https://repo1.maven.org/maven2/org/apache/avro/avro-tools/1.12.0/avro-tools-1.12.0.jar -O /tmp/avro-tools.jar

      - name: Verify Avro Tools cache
        if: steps.cache-avro.outputs.cache-hit == 'true'
        run: echo "Using cached Avro Tools"

      - name: Install Go Avro generator
        run: go install github.com/hamba/avro/v2/cmd/avrogen@latest

      - name: Validate AsyncAPI spec
        run: |
          echo "âœ“ Validating AsyncAPI specification..."
          asyncapi validate ${{ inputs.asyncapi_file }}

      - name: Validate Avro schemas
        run: |
          echo "âœ“ Validating Avro schemas with Apache Avro Tools..."
          
          # Count schemas
          schema_count=$(ls -1 ${{ inputs.avro_dir }}/*.avsc 2>/dev/null | wc -l)
          echo "Found $schema_count Avro schema(s)"
          
          if [ $schema_count -eq 0 ]; then
            echo "âŒ No Avro schemas found in ${{ inputs.avro_dir }}"
            exit 1
          fi
          
          # Validate all schemas together (to resolve cross-references)
          echo "Validating all schemas together..."
          
          # Build list of all schemas with proper ordering
          # EventMetadata must be first since other schemas reference it
          all_schemas=""
          
          # Add EventMetadata first if it exists
          if [ -f "${{ inputs.avro_dir }}/event_metadata.avsc" ]; then
            all_schemas="${{ inputs.avro_dir }}/event_metadata.avsc"
            echo "  - event_metadata.avsc (base schema)"
          fi
          
          # Add all other schemas (excluding event_metadata.avsc)
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            if [ "$(basename $schema)" != "event_metadata.avsc" ]; then
              all_schemas="$all_schemas $schema"
              echo "  - $(basename $schema)"
            fi
          done
          
          # Print input files
          echo "Input files to compile:"
          for schema in $all_schemas; do
            echo "  $(basename $schema)"
          done
          
          # Validate with all schemas in one go (resolves cross-references)
          if ! java -jar /tmp/avro-tools.jar compile schema $all_schemas /tmp/avro-validation 2>&1; then
            echo "âŒ Schema validation failed"
            exit 1
          fi
          
          echo "âœ“ All schemas are valid"
          
          # Clean up validation output
          rm -rf /tmp/avro-validation
          
          echo "âœ“ Avro schemas validated successfully"

      - name: Check schema references
        run: |
          echo "âœ“ Checking schema cross-references..."
          
          # Check if EventMetadata is referenced correctly
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schema_name=$(basename "$schema")
            
            # Skip EventMetadata itself
            if [ "$schema_name" = "event_metadata.avsc" ]; then
              continue
            fi
            
            # Check if schema references EventMetadata
            if grep -q "com.ecommerce.events.EventMetadata" "$schema"; then
              echo "âœ“ $schema_name correctly references EventMetadata"
              
              # Verify EventMetadata exists
              if [ ! -f "${{ inputs.avro_dir }}/event_metadata.avsc" ]; then
                echo "âŒ $schema_name references EventMetadata but event_metadata.avsc not found"
                exit 1
              fi
            fi
          done

      - name: Verify schema structure (metadata + payload pattern)
        run: |
          echo "âœ“ Verifying event structure follows metadata+payload pattern..."
          
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schema_name=$(basename "$schema")
            
            # Skip EventMetadata and non-event schemas
            if [[ "$schema_name" == "event_metadata.avsc" ]]; then
              continue
            fi
            
            # Check if it's an Event (ends with Event)
            if [[ "$schema_name" == *"Event"* ]] || [[ "$schema_name" == *"event.avsc" ]]; then
              # Verify it has metadata and payload fields
              if ! jq -e '.fields[] | select(.name == "metadata")' "$schema" > /dev/null; then
                echo "âš ï¸  $schema_name missing 'metadata' field"
              fi
              
              if ! jq -e '.fields[] | select(.name == "payload")' "$schema" > /dev/null; then
                echo "âš ï¸  $schema_name missing 'payload' field"
              fi
            fi
          done

      - name: Create output directory
        run: mkdir -p ${{ inputs.artifact_dir }}

      - name: Generate Go code from Avro schemas
        run: |
          echo "âœ“ Generating Go types from Avro schemas..."
          
          # Build list of all schemas with proper ordering
          # EventMetadata must be first since other schemas reference it
          all_schemas=""
          
          # Add EventMetadata first if it exists
          if [ -f "${{ inputs.avro_dir }}/event_metadata.avsc" ]; then
            all_schemas="${{ inputs.avro_dir }}/event_metadata.avsc"
          fi
          
          # Add all other schemas (excluding event_metadata.avsc)
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            if [ "$(basename $schema)" != "event_metadata.avsc" ]; then
              all_schemas="$all_schemas $schema"
            fi
          done
          
          # Generate all schemas together (to resolve cross-references)
          echo "Generating Go code for all schemas..."
          if ! $HOME/go/bin/avrogen -pkg ${{ inputs.package }} \
            -o "${{ inputs.artifact_dir }}/generated.gen.go" \
            -tags json:snake \
            $all_schemas; then
            echo "âŒ Failed to generate Go code"
            exit 1
          fi
          
          echo "âœ“ All Go code generated successfully"

      - name: Generate event type constants
        run: |
          cat > ${{ inputs.artifact_dir }}/constants.gen.go << 'EOF'
          package ${{ inputs.package }}

          import "reflect"

          // Event type constants - single source of truth for event names
          // These match the schema names and should be used in EventMetadata.EventType
          const (
          EOF
          
          # Generate constants from schema names
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            # Only generate constants for Event schemas
            if [[ "$schemaName" == *"Event" ]]; then
              # Convert ProductCreatedEvent to EventTypeProductCreated
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/EventType/')
              echo "	${constName} = \"${schemaName}\"" >> ${{ inputs.artifact_dir }}/constants.gen.go
            fi
          done
          
          echo ")" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "" >> ${{ inputs.artifact_dir }}/constants.gen.go
          
          # Generate sealed interface for exhaustiveness checking
          cat >> ${{ inputs.artifact_dir }}/constants.gen.go << 'EOF'
          // Event is a sealed interface that all event types must implement.
          // This enables exhaustiveness checking when using type switches.
          //
          // When using exhaustive linter (golangci-lint), it will warn you if you
          // don't handle all concrete Event types in a type switch.
          type Event interface {
          	isEvent() // unexported method seals the interface
          }
          EOF
          
          # Implement Event interface for each event type
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            
            if [[ "$schemaName" == *"Event" ]]; then
              echo "" >> ${{ inputs.artifact_dir }}/constants.gen.go
              echo "// ${schemaName} implements Event interface" >> ${{ inputs.artifact_dir }}/constants.gen.go
              echo "func (*${schemaName}) isEvent() {}" >> ${{ inputs.artifact_dir }}/constants.gen.go
            fi
          done
          
          # Generate topic constants from AsyncAPI spec
          echo "" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "// Topic constants - Kafka topics defined in AsyncAPI spec" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "const (" >> ${{ inputs.artifact_dir }}/constants.gen.go
          
          # Extract channels from AsyncAPI spec
          topics=$(yq eval '.channels | keys | .[]' ${{ inputs.asyncapi_file }})
          
          for topic in $topics; do
            # Convert topic name to constant name
            # e.g., catalog.product.events -> TopicCatalogProductEvents
            constName=$(echo "$topic" | sed 's/\./ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2)); print "Topic"$0}' | tr -d ' ')
            echo "	${constName} = \"${topic}\"" >> ${{ inputs.artifact_dir }}/constants.gen.go
          done
          
          echo ")" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "" >> ${{ inputs.artifact_dir }}/constants.gen.go
          
          # Generate schema name constants
          echo "// Schema name constants - Avro schema full names (namespace.name)" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "const (" >> ${{ inputs.artifact_dir }}/constants.gen.go
          
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            namespace=$(jq -r '.namespace' "$schema" 2>/dev/null || echo "")
            
            if [[ "$schemaName" == *"Event" ]] && [[ -n "$namespace" ]]; then
              fullName="${namespace}.${schemaName}"
              # Convert ProductCreatedEvent to SchemaNameProductCreated
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/SchemaName/')
              echo "	${constName} = \"${fullName}\"" >> ${{ inputs.artifact_dir }}/constants.gen.go
            fi
          done
          
          echo ")" >> ${{ inputs.artifact_dir }}/constants.gen.go
          echo "" >> ${{ inputs.artifact_dir }}/constants.gen.go
          
          # Generate default type mapping
          cat >> ${{ inputs.artifact_dir }}/constants.gen.go << 'EOF'
          // DefaultTypeMapping is a pre-configured mapping of Avro schema full names to Go types.
          // Use this with consumer.RegisterTypeMapping() to deserialize events.
          //
          // Example:
          //   consumer.RegisterTypeMapping(events.DefaultTypeMapping)
          var DefaultTypeMapping = map[string]reflect.Type{
          EOF
          
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            namespace=$(jq -r '.namespace' "$schema" 2>/dev/null || echo "")
            
            if [[ "$schemaName" == *"Event" ]] && [[ -n "$namespace" ]]; then
              # Convert ProductCreatedEvent to SchemaNameProductCreated
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/SchemaName/')
              echo "	${constName}: reflect.TypeOf(${schemaName}{}),  " >> ${{ inputs.artifact_dir }}/constants.gen.go
            fi
          done
          
          echo "}" >> ${{ inputs.artifact_dir }}/constants.gen.go

      - name: Copy AsyncAPI spec
        run: |
          echo "Copying AsyncAPI spec..."
          cp ${{ inputs.asyncapi_file }} ${{ inputs.artifact_dir }}/asyncapi.yaml

      - name: Copy Avro schemas
        run: |
          echo "Copying Avro schemas..."
          mkdir -p ${{ inputs.artifact_dir }}/schemas
          cp ${{ inputs.avro_dir }}/*.avsc ${{ inputs.artifact_dir }}/schemas/

      - name: Generate schema embeddings
        run: |
          cat > ${{ inputs.artifact_dir }}/schemas.gen.go << 'EOF'
          package ${{ inputs.package }}

          import _ "embed"

          //go:embed asyncapi.yaml
          var AsyncAPISpec []byte

          EOF

          # Add embedded Avro schemas
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            varname=$(echo "$basename" | sed -E 's/(^|_)([a-z])/\U\2/g')
            echo "//go:embed schemas/${basename}.avsc" >> ${{ inputs.artifact_dir }}/schemas.gen.go
            echo "var ${varname}Schema []byte" >> ${{ inputs.artifact_dir }}/schemas.gen.go
            echo "" >> ${{ inputs.artifact_dir }}/schemas.gen.go
          done
          
          # Generate combined schemas (EventMetadata + Event) for serialization
          echo "// Combined schemas with EventMetadata embedded for Avro serialization" >> ${{ inputs.artifact_dir }}/schemas.gen.go
          echo "// These resolve named type references like \"com.ecommerce.events.EventMetadata\"" >> ${{ inputs.artifact_dir }}/schemas.gen.go
          echo "" >> ${{ inputs.artifact_dir }}/schemas.gen.go
          
          # Check if EventMetadata exists
          if [ -f "${{ inputs.avro_dir }}/event_metadata.avsc" ]; then
            # For each event schema, create a combined version
            for schema in ${{ inputs.avro_dir }}/*.avsc; do
              basename=$(basename "$schema" .avsc)
              
              # Skip EventMetadata itself
              if [ "$basename" = "event_metadata" ]; then
                continue
              fi
              
              # Only process event schemas
              if [[ "$basename" == *"_created" ]] || [[ "$basename" == *"_updated" ]] || [[ "$basename" == *"_event" ]]; then
                # Create combined schema JSON array: [EventMetadata, EventSchema]
                echo "[" > "${{ inputs.artifact_dir }}/schemas/${basename}_combined.json"
                cat "${{ inputs.avro_dir }}/event_metadata.avsc" >> "${{ inputs.artifact_dir }}/schemas/${basename}_combined.json"
                echo "," >> "${{ inputs.artifact_dir }}/schemas/${basename}_combined.json"
                cat "$schema" >> "${{ inputs.artifact_dir }}/schemas/${basename}_combined.json"
                echo "]" >> "${{ inputs.artifact_dir }}/schemas/${basename}_combined.json"
                
                # Add to Go file
                varname=$(echo "${basename}" | sed -E 's/(^|_)([a-z])/\U\2/g')
                echo "//go:embed schemas/${basename}_combined.json" >> ${{ inputs.artifact_dir }}/schemas.gen.go
                echo "var ${varname}CombinedSchema []byte // Use this for Serialize() - includes EventMetadata" >> ${{ inputs.artifact_dir }}/schemas.gen.go
                echo "" >> ${{ inputs.artifact_dir }}/schemas.gen.go
              fi
            done
          fi

      - name: Validate generated Go code
        run: |
          echo "âœ“ Validating generated Go code..."
          
          cd ${{ inputs.artifact_dir }}
          
          # Create a temporary go.mod if needed
          if [ ! -f "go.mod" ]; then
            go mod init github.com/${{ github.repository }}/${{ inputs.artifact_dir }}
            go mod tidy
          fi
          
          # Check if code compiles
          if ! go build -o /dev/null *.go 2>&1; then
            echo "âŒ Generated Go code does not compile"
            exit 1
          fi
          
          # Remove go.mod and go.sum (not needed in artifact)
          rm -f go.mod go.sum
          
          echo "âœ“ Generated Go code is valid and compiles"

      - name: Generate README
        run: |
          cat > ${{ inputs.artifact_dir }}/README.gen.md << 'EOF'
          # Generated Messaging API

          This package is auto-generated from AsyncAPI and Avro schemas.

          ## ðŸ“¦ What's Included

          - **Go Types**: Generated from Avro schemas using `avrogen`
          - **Event Constants**: Type-safe constants for event types and topics
          - **Schema Embeddings**: Avro schemas embedded as `[]byte` for runtime access
          - **Sealed Interface**: Exhaustiveness checking for event handlers

          ## ðŸ”§ Usage with Schema Registry

          This package is designed to work with Confluent Schema Registry for production use.

          ### Producer Example

          ```go
          import (
              "${{ inputs.package }}"
              "github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/schemaregistry"
          )

          // Create Schema Registry serializer
          serializer, err := schemaregistry.NewSerializer(schemaregistry.Config{
              URL:                 "http://localhost:8081",
              AutoRegisterSchemas: true,
          })
          if err != nil {
              log.Fatal(err)
          }
          defer serializer.Close()

          // Create event
          event := &${{ inputs.package }}.YourEventName{
              Metadata: ${{ inputs.package }}.EventMetadata{
                  EventID:       uuid.New().String(),
                  EventType:     ${{ inputs.package }}.EventTypeYourEvent, // Use constant!
                  Source:        "your-service",
                  Timestamp:     time.Now().UnixMilli(),
                  CorrelationID: correlationID,
                  TraceID:       traceID,
              },
              Payload: ${{ inputs.package }}.YourEventPayload{
                  // ... your payload fields
              },
          }

          // Serialize with Schema Registry (auto-registers schema)
          bytes, err := serializer.Serialize("your.topic-value", event)
          if err != nil {
              log.Fatal(err)
          }

          // Send to Kafka
          producer.Produce(&kafka.Message{
              TopicPartition: kafka.TopicPartition{
                  Topic:     &${{ inputs.package }}.TopicYourTopic,
                  Partition: kafka.PartitionAny,
              },
              Value: bytes, // Contains [0x00][schema_id][avro_data]
              Key:   []byte(entityID),
          })
          ```

          ### Consumer Example

          ```go
          import (
              "${{ inputs.package }}"
              "github.com/Sokol111/ecommerce-commons/pkg/messaging/kafka/schemaregistry"
          )

          // Create Schema Registry deserializer
          deserializer, err := schemaregistry.NewDeserializer(schemaregistry.Config{
              URL: "http://localhost:8081",
          })
          if err != nil {
              log.Fatal(err)
          }
          defer deserializer.Close()

          // Receive from Kafka
          msg := <-consumer.Events()

          // Deserialize (schema fetched from Registry by ID)
          event, err := deserializer.Deserialize("your.topic-value", msg.Value)
          if err != nil {
              log.Fatal(err)
          }

          // Type switch with exhaustiveness checking
          switch e := event.(type) {
          case *${{ inputs.package }}.YourEventName:
              handleYourEvent(e)
          // Add cases for all event types - linter will warn if you miss one
          default:
              log.Printf("unhandled event type: %T", event)
          }
          ```

          ## ðŸŽ¯ Event Type Constants

          Always use the generated constants for `EventMetadata.EventType`:

          EOF
          
          # List event type constants
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            schemaName=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            if [[ "$schemaName" == *"Event" ]]; then
              constName=$(echo "$schemaName" | sed 's/Event$//' | sed 's/^/EventType/')
              echo "- \`${{ inputs.package }}.${constName}\` = \"${schemaName}\"" >> ${{ inputs.artifact_dir }}/README.gen.md
            fi
          done
          
          cat >> ${{ inputs.artifact_dir }}/README.gen.md << 'EOF'

          ## Embedded Resources

          - AsyncAPI specification: `${{ inputs.package }}.AsyncAPISpec`
          - Avro schemas: `${{ inputs.package }}.*Schema` variables

          ## Exhaustiveness Checking

          All event types implement the sealed `Event` interface:

          ```go
          type Event interface {
              isEvent() // unexported method - seals the interface
          }
          ```

          This enables exhaustiveness checking in type switches. When using `golangci-lint` with 
          the `exhaustive` linter, you'll get compile-time warnings if you don't handle all event types:

          ```go
          func handleEvent(event ${{ inputs.package }}.Event) error {
              switch e := event.(type) {
              case *${{ inputs.package }}.ProductCreatedEvent:
                  // handle created
              case *${{ inputs.package }}.ProductUpdatedEvent:
                  // handle updated
              // exhaustive linter will warn if you forget any Event type!
              default:
                  return fmt.Errorf("unhandled event: %T", event)
              }
          }
          ```

          **Configure golangci-lint:**

          ```yaml
          linters-settings:
            exhaustive:
              default-signifies-exhaustive: false
              explicit-exhaustive-switch: true
          ```

          ## Available Schemas" >> ${{ inputs.artifact_dir }}/README.gen.md
          echo "" >> ${{ inputs.artifact_dir }}/README.gen.md
          for schema in ${{ inputs.avro_dir }}/*.avsc; do
            basename=$(basename "$schema" .avsc)
            varname=$(echo "$basename" | sed -E 's/(^|_)([a-z])/\U\2/g')
            schema_type=$(jq -r '.name' "$schema" 2>/dev/null || echo "Unknown")
            echo "- \`${{ inputs.package }}.${varname}Schema\` - $schema_type (embedded Avro schema)" >> ${{ inputs.artifact_dir }}/README.gen.md
          done
          
          cat >> ${{ inputs.artifact_dir }}/README.gen.md << 'EOF'

          ## ðŸ“– Schema Registry Benefits

          ### Why Schema Registry?

          - âœ… **Centralized schema storage** - Single source of truth
          - âœ… **Automatic versioning** - Track schema evolution
          - âœ… **Compatibility checking** - Prevent breaking changes
          - âœ… **Schema ID in messages** - Efficient wire format
          - âœ… **No code regeneration** - Schema changes don't require service redeployment

          ### Wire Format

          Messages are serialized as: `[0x00][schema_id (4 bytes)][avro_data]`

          This allows consumers to fetch the exact schema used for serialization from the Registry.

          ### Compatibility Modes

          - **BACKWARD** (recommended): New consumers can read old data
          - **FORWARD**: Old consumers can read new data
          - **FULL**: Both BACKWARD and FORWARD
          - **NONE**: No compatibility checks

          ## ðŸ”§ Configuration

          Add to your service config:

          ```yaml
          kafka:
            brokers: "kafka:29092"
            schema-registry:
              url: "http://schema-registry:8081"
              auto-register-schemas: true
              cache-capacity: 1000
          ```

          EOF

      - name: Upload built messaging API
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact }}
          path: ${{ inputs.artifact_dir }}
